// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package example

type wrapperstringint struct {
	Key   string
	Value int
	Valid bool
}

type XYMapStringInt struct {
	mapping map[string]int
	storage []*wrapperstringint
	empty   int
}

func NewXYMapStringInt() *XYMapStringInt {
	return &XYMapStringInt{
		mapping: map[string]int{},
	}
}

func (xym *XYMapStringInt) Set(key string, value int) (subs int, existed bool) {
	if idx, ok := xym.mapping[key]; ok {
		slot := xym.storage[idx]
		subs = slot.Value
		existed = true
		slot.Value = value
		return
	}
	xym.mapping[key] = len(xym.storage)
	xym.storage = append(xym.storage, &wrapperstringint{
		Key:   key,
		Value: value,
		Valid: true,
	})
	return
}

func (xym *XYMapStringInt) Get(key string) (value int, existed bool) {
	if idx, ok := xym.mapping[key]; ok {
		slot := xym.storage[idx]
		value = slot.Value
		existed = true
	}
	return
}

// Delete the key and the opposite value
func (xym *XYMapStringInt) Delete(key string) (value int, existed bool) {
	if idx, ok := xym.mapping[key]; ok {
		slot := xym.storage[idx]
		value = slot.Value
		slot.Valid = false
		existed = true
		delete(xym.mapping, key)
		xym.empty++
		if xym.empty > 10 && float32(xym.empty)/float32(len(xym.storage)) > 0.8 {
			xym.Compress()
		}
		return
	}
	return
}

// Compress the storage
func (xym *XYMapStringInt) Compress() {
	wid := 0
	rid := len(xym.storage) - 1
	for ; rid >= wid; rid-- {
		slot := xym.storage[rid]
		if slot.Valid {
			for ; wid < rid && xym.storage[wid].Valid; wid++ {
			}
			xym.mapping[slot.Key] = wid
			xym.storage[wid] = slot
		}
	}
	xym.storage = xym.storage[:wid+1]
	xym.empty = 0
	return
}

func (xym *XYMapStringInt) Iterate(callback func(key string, value int) bool) {
	length := len(xym.storage)
	for i := 0; i < length; i++ {
		slot := xym.storage[i]
		if slot.Valid {
			flag := callback(slot.Key, slot.Value)
			if !flag {
				break
			}
		}
	}
}

func (xym *XYMapStringInt) Length() int {
	return len(xym.storage) - xym.empty
}

type wrapperintint struct {
	Key   int
	Value int
	Valid bool
}

type XYMapIntInt struct {
	mapping map[int]int
	storage []*wrapperintint
	empty   int
}

func NewXYMapIntInt() *XYMapIntInt {
	return &XYMapIntInt{
		mapping: map[int]int{},
	}
}

func (xym *XYMapIntInt) Set(key int, value int) (subs int, existed bool) {
	if idx, ok := xym.mapping[key]; ok {
		slot := xym.storage[idx]
		subs = slot.Value
		existed = true
		slot.Value = value
		return
	}
	xym.mapping[key] = len(xym.storage)
	xym.storage = append(xym.storage, &wrapperintint{
		Key:   key,
		Value: value,
		Valid: true,
	})
	return
}

func (xym *XYMapIntInt) Get(key int) (value int, existed bool) {
	if idx, ok := xym.mapping[key]; ok {
		slot := xym.storage[idx]
		value = slot.Value
		existed = true
	}
	return
}

// Delete the key and the opposite value
func (xym *XYMapIntInt) Delete(key int) (value int, existed bool) {
	if idx, ok := xym.mapping[key]; ok {
		slot := xym.storage[idx]
		value = slot.Value
		slot.Valid = false
		existed = true
		delete(xym.mapping, key)
		xym.empty++
		if xym.empty > 10 && float32(xym.empty)/float32(len(xym.storage)) > 0.8 {
			xym.Compress()
		}
		return
	}
	return
}

// Compress the storage
func (xym *XYMapIntInt) Compress() {
	wid := 0
	rid := len(xym.storage) - 1
	for ; rid >= wid; rid-- {
		slot := xym.storage[rid]
		if slot.Valid {
			for ; wid < rid && xym.storage[wid].Valid; wid++ {
			}
			xym.mapping[slot.Key] = wid
			xym.storage[wid] = slot
		}
	}
	xym.storage = xym.storage[:wid+1]
	xym.empty = 0
	return
}

func (xym *XYMapIntInt) Iterate(callback func(key int, value int) bool) {
	length := len(xym.storage)
	for i := 0; i < length; i++ {
		slot := xym.storage[i]
		if slot.Valid {
			flag := callback(slot.Key, slot.Value)
			if !flag {
				break
			}
		}
	}
}

func (xym *XYMapIntInt) Length() int {
	return len(xym.storage) - xym.empty
}
